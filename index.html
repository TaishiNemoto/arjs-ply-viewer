<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>AR.js PLY Diagnostic</title>

  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
    #hud{
      position:fixed; left:10px; top:10px; z-index:99999;
      padding:10px 12px; border-radius:10px;
      background:rgba(0,0,0,.65); color:#fff;
      font:13px/1.4 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial;
      max-width:92vw; white-space:pre-wrap;
    }
  </style>

  <script>
    // いちばん最初にエラー捕捉を仕込む（外部ライブラリが死んでも表示できるように）
    function log(msg){
      const hud = document.getElementById("hud");
      if (hud) hud.textContent += "\n" + msg;
    }
    window.addEventListener("error", (e) => {
      log("JSエラー: " + (e.message || "unknown"));
    });
    window.addEventListener("unhandledrejection", (e) => {
      log("Promiseエラー: " + (e.reason?.message || e.reason || "unknown"));
    });
  </script>

  <!-- どこまで読み込めたかをHUDに出す -->
  <script>
    document.addEventListener("DOMContentLoaded", () => log("DOM loaded"));
    setTimeout(() => log("5秒経過: ここまで来てるか確認"), 5000);
  </script>

  <script
    src="https://unpkg.com/aframe@1.5.0/dist/aframe.min.js"
    onload="log('A-Frame loaded')"
    onerror="log('A-Frame load failed')"
  ></script>

  <script
    src="https://unpkg.com/ar.js@3.4.5/aframe/build/aframe-ar.js"
    onload="log('AR.js loaded')"
    onerror="log('AR.js load failed')"
  ></script>

  <!-- A-Frameが使っているTHREEに合わせる -->
  <script
    src="https://unpkg.com/three@0.152.2/examples/js/loaders/PLYLoader.js"
    onload="log('PLYLoader loaded')"
    onerror="log('PLYLoader load failed')"
  ></script>

  <script>
    // ここまで来たら「自前JSは動いてる」
    log("inline script running");

    // AFRAMEが読めているかをチェック
    const waitAFRAME = setInterval(() => {
      if (window.AFRAME) {
        clearInterval(waitAFRAME);
        log("AFRAME detected");
        boot();
      }
    }, 100);

    function boot(){
      // ここで落ちるならHUDに出る
      AFRAME.registerComponent("ply-pointcloud", {
        schema: {
          src: { type: "string", default: "./web-model.ply" },
          scale: { type: "number", default: 0.01 },
          pointSize: { type: "number", default: 0.02 },
          maxPoints: { type: "int", default: 80000 }
        },
        init(){
          log("component init: start loading PLY");
          if (!window.THREE) { log("THREE missing"); return; }
          if (!THREE.PLYLoader) { log("PLYLoader missing"); return; }

          const loader = new THREE.PLYLoader();
          loader.load(
            this.data.src,
            (geometry) => {
              log("PLY loaded: vertices=" + geometry.attributes.position.count);

              geometry.computeBoundingBox();
              const c = new THREE.Vector3();
              geometry.boundingBox.getCenter(c);
              geometry.translate(-c.x, -c.y, -c.z);

              // 間引き
              let g = geometry;
              const total = g.attributes.position.count;
              if (total > this.data.maxPoints) {
                g = downsample(g, this.data.maxPoints);
                log("downsample: " + total + " -> " + g.attributes.position.count);
              }

              const mat = new THREE.PointsMaterial({ size: this.data.pointSize, vertexColors: g.hasAttribute("color") });
              const pts = new THREE.Points(g, mat);
              pts.scale.setScalar(this.data.scale);

              this.el.object3D.add(pts);
              log("points added. show marker.");
            },
            (xhr) => {
              if (xhr && xhr.total) log("PLY loading " + Math.round(xhr.loaded/xhr.total*100) + "%");
            },
            (err) => {
              log("PLY load error: " + (err?.message || err || "unknown"));
            }
          );

          function downsample(src, target){
            const pos = src.getAttribute("position");
            const col = src.getAttribute("color");
            const total = pos.count;
            const step = total / target;

            const newPos = new Float32Array(target * 3);
            const newCol = col ? new Float32Array(target * 3) : null;

            for (let i=0;i<target;i++){
              const base = Math.floor(i * step);
              const j = Math.min(total - 1, base + Math.floor(Math.random() * Math.max(1, Math.floor(step))));
              newPos[i*3+0]=pos.array[j*3+0];
              newPos[i*3+1]=pos.array[j*3+1];
              newPos[i*3+2]=pos.array[j*3+2];
              if (newCol){
                newCol[i*3+0]=col.array[j*3+0];
                newCol[i*3+1]=col.array[j*3+1];
                newCol[i*3+2]=col.array[j*3+2];
              }
            }
            const g = new THREE.BufferGeometry();
            g.setAttribute("position", new THREE.BufferAttribute(newPos, 3));
            if (newCol) g.setAttribute("color", new THREE.BufferAttribute(newCol, 3));
            return g;
          }
        }
      });
      log("component registered");
    }
  </script>
</head>

<body>
  <div id="hud">起動中…</div>

  <a-scene embedded vr-mode-ui="enabled:false" arjs="sourceType: webcam; debugUIEnabled:false;">
    <a-marker type="pattern" url="./default-marker.patt">
      <a-entity ply-pointcloud="src: ./web-model.ply; scale: 0.01; pointSize: 0.02; maxPoints: 80000"></a-entity>
    </a-marker>
    <a-entity camera></a-entity>
  </a-scene>
</body>
</html>



